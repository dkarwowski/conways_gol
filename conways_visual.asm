
#################################################################################################
#                             Visualization for Conway's Game of Life							#
#																								#
#  Padraic Edgington                                                    	     11 April, 2013	#
#																								#
#                                               v. 1											#
#																								#
#  You should write your code in a seperate file and prepend it to this file by running			#
#  either:																						#
#  Windows: copy /Y <Life Function Name>.asm + "Program #9 - Visualization.asm" <output>.asm	#
#  Unix:    cat <Life Function Name>.asm "Program #9 - Visualization.asm" > <output>.asm		#
#																								#
#  Notes:  Change the object being visualized by choosing a different name in the la			#
#  instruction at the main label.																#
#																								#
#  v. 1		Initial release (more objects may be added later)									#
#################################################################################################

				.data
Block_State:	.word	4, 4
				.byte	0x06, 0x60
Loaf_State:		.word	6, 6
				.byte	0x00, 0xC4, 0x8A, 0x10, 0x00

Toad_State:		.word	6, 6
				.byte	0x00, 0x03, 0x9C, 0x00, 0x00

Glider_State:	.word	5, 5
				.byte	0x01, 0x04, 0xE0, 0x00
				
R_pentomino:	.word	27, 27
				.byte	0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x60 0x00 0x00 0x18 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
				
Infinite1:		.word	48, 48
				.byte	0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x02 0x00 0x00 0x00 0x00 0x00 0x0B 0x00 0x00 0x00 0x00 0x00 0x0A 0x00 0x00 0x00 0x00 0x00 0x08 0x00 0x00 0x00 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0xA0 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
				
Continue:		.asciiz "Press enter to continue.\n"				
				.text

main:	la		$v0, Glider_State		#  The object to display.
loop:	move	$a0, $v0
		move	$s0, $v0
		jal		Life_Print				#  Display the current state
		
		li		$v0, 4
		la		$a0, Continue
		syscall
		li		$v0, 5
		syscall							#  Remove this line to run as fast as possible.
		
		move	$a0, $s0
		jal		Life					#  Update the state
		j		loop
		
		
Life_Print:
###############################################################################
			.data
row_start:	.asciiz ""
row_end:	.asciiz "|\n"
clr_screen:	.asciiz "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
alive:		.asciiz "|X"
dead:		.asciiz "| "
			.text
		lw		$t0, 0 ($a0)		#  Get the number of rows
		lw		$t1, 4 ($a0)		#  Get the number of columns
		addi	$t8, $a0, 7			#  Store the base of the array in $t8
		
		li		$t2, 0				#  Row iterator
		li		$t3, 0				#  Column iterator
		li		$t4, 8				#  Buffer iterator
 		lb		$t5, 0 ($t8)		#  Initialize buffer
 		li		$t6, 0x80			#  Initialize mask
		li		$t7, 8				#  Buffer length
		
		li		$v0, 4
		la		$a0, clr_screen
		syscall
		
		li		$v0, 4
		la		$a0, row_start
		syscall
		
LP_Loop:
		addi	$t4, $t4, 1			#  Increment the buffer
		srl		$t6, $t6, 1			#  Increment the mask
		blt		$t4, $t7, LP_Buffer_OK
		
		addi	$t8, $t8, 1			#  Shift the buffer window to the right
		li		$t4, 0				#  Reinitialize the buffer iterator
		lbu		$t5, 0 ($t8)		#  Load the next block of data
		li		$t6, 0x80			#  Reinitialize the mask

LP_Buffer_OK:
		and		$t9, $t5, $t6		#  Apply a mask to the buffer
		beqz	$t9, LP_Dead		#  If the cell is 0, then it's dead.
		
		li		$v0, 4
		la		$a0, alive
		syscall						#  Print a # to indicate a live cell
		j		LP_Continue
		
LP_Dead:
		li		$v0, 4
		la		$a0, dead			#  Print a blank space to indicate a dead cell.
		syscall
		
LP_Continue:
		addi	$t3, $t3, 1			#  Increment the column iterator
		blt		$t3, $t1, LP_Loop	#  If the column iterator is less than the number of columns, print another column
		
		addi	$t2, $t2, 1			#  Increment the row iterator
		li		$t3, 0				#  Reinitialize the column iterator
		li		$v0, 4
		la		$a0, row_end
		syscall						#  Print the end of the row
		
		bge		$t2, $t0, LP_Done	#  If the row iterator is >= to the number of rows, then we are done.
		
		li		$v0, 4
		la		$a0, row_start
		syscall						#  Print the beginning of another row
		
		j		LP_Loop
		
LP_Done:
		jr	$ra
		
